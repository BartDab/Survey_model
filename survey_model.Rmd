---
title: "RF"
author: "Bartosz Dąbrowski"
date: "3 05 2020"
output: html_document
---

```{r }
require(tidyverse)
require(stringr)
require(tm)
require(randomForest)
```

Do zaimportowania użyłem pakietu readr, aby uniknąć problemu z niepoprawnym odczytywaniem polskich znaków przez read.csv().

```{r }
data <- read_delim("E:/survey_model/dane_2.tsv", "\t", 
    escape_double = FALSE, trim_ws = TRUE)
head(data,10)
str(data)
```

###Oczyszczanie danych###
###PAMIĘTAJ ŻEBY ŚCIĄGNĄĆ NOWE DANE BO MASZ NOWE ODPOWIEDZI###

Dane w formie tekstu zmieniam na factory.

```{r }
data<-as.data.frame(data)

#data[,2]<-parse_factor(data[,2],levels=unique(sort(data[,2])))
data[,4]<-parse_factor(data[,4],levels=unique(sort(data[,4])))
data[,5]<-parse_factor(data[,5],levels=c("poniżej 5 tysięcy","5 - 20 tysięcy","20 - 100 tysięcy", "100 - 200 tysięcy","200 - 500 tysięcy","powyżej 500 tysięcy"))
#data[,7]<-parse_factor(data[,7],levels=c("Tak","Nie"))
data[,8]<-parse_factor(data[,8],levels=c("I","II","III","IV","V","Ukończyłem/ukończyłam studia"))
#data[,9]<-parse_factor(data[,9],levels=c("Publiczna","Prywatna"))
#data[,10]<-parse_factor(data[,10],levels=unique(sort(data[,10])))
data[,11]<-parse_factor(data[,11],levels=c("Artystyczna","Ekonomiczna","Pedagogiczna","Techniczna","Uniwersytet","Inna"))
data[,12]<-parse_factor(data[,12],levels=c("Architektura","Automatyka/elektrotechnika","Biologia","Chemia","Dziennikarstwo/komunikacja społeczna","Ekonometria","Ekonomia/finanse","Farmacja","Filologia","Fizyka/astronomia","Geografia","Historia","Informatyka/telekomunikacja","Inżynieria biomedyczna","Inżynieria chemiczna","Inżynieria lądowa/budownictwo/transport","Inżynieria materiałowa","Inżynieria mechaniczna","Inżynieria środowiska/energetyka/górnictwo","Kulturoznawstwo/religioznawstwo","Matematyka","Medycyna","Nauki o bezpieczeństwie","Pedagogika","Prawo/administracja","Psychologia","Socjologia","Sztuki piękne","Technologia żywności","Weterynaria/zootechnika","Zarządzanie","Inne"))
#data[,13]<-parse_factor(data[,13],levels=c("Tak","Nie"))
#data[,14]<-parse_factor(data[,14],levels=c("Tak","Nie"))
#data[,15]<-parse_factor(data[,15],levels=c("Tak","Nie"))
data[,16]<-parse_factor(data[,16],levels=unique(sort(data[,16])))
#data[,17]<-parse_factor(data[,17],levels=c("Tak","Nie"))
#data[,18]<-parse_factor(data[,18],levels=c("Akademik","Dom/mieszkanie rodzinne","Wynajęte mieszkanie","Wynajęty pokój","Inne"))
data[,28]<-parse_factor(data[,28],levels=c("Jeszcze nie pracuję","Przed początkiem studiów","I rok","II rok", "III rok","IV rok","V rok", "Później"))

head(data)
```

W 2 pytaniach otwartych należy oczyścić odpowiedzi.

```{r}
table(data[,6])
data[,3] <- replace(data[,3],data[,3]=="19, rocznikowo 20", "19")
data[,3]<-as.numeric(data[,3])
Krk<-c('Kraków','Krakow','krk','Krakó','Kraków xD')
data[,6]<-gsub(paste(Krk, collapse = '|'), 'Kraków', data[,6])
Krk<-c('Warszawa','Wawa','Warszasa')
data[,6]<-gsub(paste(Krk, collapse = '|'), 'Warszawa', data[,6])
Krk<-c("Poznań","poznań","Poznan")
data[,6]<-gsub(paste(Krk, collapse = '|'), 'Poznań', data[,6])
Krk<-c('Gdańsk','Gdansk')
data[,6]<-gsub(paste(Krk, collapse = '|'), 'Gdańsk', data[,6])

Krk<-c("BIAŁYSTOK", "Białystok")
data[,6]<-gsub(paste(Krk, collapse = '|'), 'Białystok', data[,6])

Krk<-c("słupsk", "Słupsk")
data[,6]<-gsub(paste(Krk, collapse = '|'), 'Słupsk', data[,6])

Krk<-c("Deblin", "Dęblin")
data[,6]<-gsub(paste(Krk, collapse = '|'), 'Dęblin', data[,6])

Krk<-c("Toruń, Poznań", "Toruń")
data[,6]<-gsub(paste(Krk, collapse = '|'), 'Toruń', data[,6])

data[,6] <- replace(data[,6],data[,6]=="Uniwersytet Śląski", "Katowice")

table(data[,6])
head(data)
```

Zmieniam factory z 2 odpowiedziami na zmienne zero-jedynkowe.

```{r}
data[,2]<-if_else(data[,2]=="Kobieta",1,0)
data[,6]<-parse_factor(data[,6],levels=unique(sort(data[,6])))
data[,9]<-if_else(data[,9]=="Prywatna",1,0)
data[,10]<-if_else(data[,10]=="Zaocznie",1,0)
data[,7]<-if_else(data[,7]=="Tak",1,0)
data[,13:15]<-if_else(data[,13:15]=="Tak",1,0)
data[,17]<-if_else(data[,17]=="Tak",1,0)
head(data)
```

Odpowiedzi do pytania o lokum wyeksportowane zostały w formie tekstowej, z zaznaczonymi opcjami wymienionymi po przecinku. Aby to wyodrębnić, używam kombinacji if_else i str_detect.

```{r}
data<-data%>%
  mutate(Akademik=if_else(str_detect(data[,18],coll("Akademik")),1,0),
         Dom_mieszkanie_rodzinne=if_else(str_detect(data[,18],coll("Dom/mieszkanie rodzinne")),1,0),
         Wynajete_mieszkanie=if_else(str_detect(data[,18],coll("Wynajęte mieszkanie")),1,0),
         Wynajety_pokoj=if_else(str_detect(data[,18],coll("Wynajęty pokój")),1,0),
         Inne=if_else(str_detect(data[,18],coll("Inne")),1,0))
```
df - oczyszczona wersja danych
Wyrzucam kolumnę z feedbackiem, sygnaturę czasową oraz pytanie o lokum, które zostało już rozbite.

```{r}
df<-data[,-29]
df<-df[,-18]
df<-df[,-1]
```

Dla większej czytelności zmieniam nazwy zmiennych.

```{r}
colnames(df)[1:31]<-c('Kobieta','Wiek','Wojewodztwo_pochodzenia', 'Wielkosc_miasta', 'Miasto', 'Wiecej_kierunkow', 'Rok','Prywatna','Zaocznie', 'Typ','Dziedzina','Kola','Organizacje','Samorzad','Srednia','Stypendium','Wiodace','Zapychacze','Zapychacze_dobor','Jezyk','Organizacja_uczelni','Plany','Trudnosc','Przydatnosc','Ogolna_ocena','Praca','Akademik','Dom_mieszkanie_rodzinne','Wynajete_mieszkanie','Wynajety_pokoj','Inne')
colnames(df)
```

Mniej więcej w tym miejscu zaczyna się ściernisko, ale będzie San Francisco.

próba random forest

```{r}
model_rf<-randomForest::randomForest(Praca~.,data=df)
print(model_rf)
```

Od razu widoczne są problemy - ledwie pojedyncze przeypadki są klasyfikowane inaczej, niż jako "jeszcze nie pracuję". Output jest niezbalansowany, ponad połowa osób wpada do jednej opcji, więc model wyciąga błędne wnioski.

Zacznę od uogólnienia kolumny dziedzina studiów, posługując się aktualnymi dyscyplinami, do których przypisane są kierunki - są one bardzo niedokładne, ale stanowią chociaż jakąś podstawę do klasyfikacji.

```{r}
levels(df$Dziedzina)
df2<-df%>%
  mutate(Dyscyplina = ifelse(Dziedzina %in% c('Biologia','Chemia', 'Geografia'),'Nauki przyrodnicze',ifelse(Dziedzina %in% c('Psychologia','Socjologia','Zarządzanie','Nauki o bezpieczeństwie','Pedagogika','Ekonomia/finanse','Ekonometria','Prawo/administracja','Dziennikarstwo/komunikacja społeczna'),'Nauki spoleczne',ifelse(Dziedzina %in% c('Inżynieria biomedyczna','Inżynieria chemiczna','Inżynieria materiałowa','Inżynieria mechaniczna','Inżynieria środowiska/energetyka/górnictwo','Inżynieria lądowa/budownictwo/transport',"Architektura","Automatyka/elektrotechnika"),'Nauki inzynieryjno-techniczne',ifelse(Dziedzina %in% c('Historia','Kulturoznawstwo/religioznawstwo',"Filologia"),'Nauki humanistyczne',ifelse(Dziedzina %in% c('Medycyna','Farmacja'),'Nauki o zdrowiu',ifelse(Dziedzina %in% c('Fizyka/astronomia','Informatyka/telekomunikacja',"Matematyka"),'Nauki scisle',ifelse(Dziedzina %in% c("Technologia żywności","Weterynaria/zootechnika" ),'Nauki rolnicze',levels(df$Dziedzina)[Dziedzina]))))))))
#this code is ugly as fuck, but well, at least it's work
df2[,32]<-parse_factor(df2[,32],levels=unique(sort(df2[,32])))
levels(df2[,31])
df2<-df2[,-11]
head(df2)
```

Kolejnym etapem jest powiązanie miast, które w praktyce mogą być traktowane jako jedno - Trójmiasta oraz konurbacji śląskiej.

```{r}
df3<-df2
unique(df3[,5])
Wekt<-c('Gdańsk','Gdynia','Sopot')
df3[,5]<-gsub(paste(Wekt, collapse = '|'), 'Trójmiasto', df3[,5])
Wekt<-c('Katowice','Bytom','Gliwice','Sosnowiec','Zabrze')
df3[,5]<-gsub(paste(Wekt, collapse = '|'), 'Śląsk', df3[,5])
df3[,5]<-parse_factor(df3[,5],levels=unique(sort(df3[,5])))
```

Ostatnim elementem jest uproszczenie outputu - opcja niepracująca to ponad 60% odpowiedzi, podczas gdy II stopień i "później" to niespełna 5%. W tej chwili rozważam usunięcie odpowiedzi bądź połączenie ich z III rokiem, ale na razie się wstrzymam. Rozwiązaniem być może byłoby też odpowiednie próbkowanie.

```{r}
table(df3$Praca)
levels(df3$Praca)
df4<-df3
Wekt<-c('I rok','II rok','III rok')
df4[,25]<-gsub(paste(Wekt, collapse = '|'), 'I stopień', df4[,25])
Wekt<-c('IV rok', 'V rok', 'Później')
df4[,25]<-gsub(paste(Wekt, collapse = '|'), 'II stopień i później', df4[,25])
df4[,25]<-parse_factor(df4[,25],levels=unique(sort(df4[,25])))
```

Również ważne - należy pobawić się więcej z parametrami oraz miarami, problemem jest bardzo niski odsetek dla II stopnia, później i przed początkiem.

Opcje do spróbowania:
algorytm SMOTE
"przed", "I rok", "II rok", "III i później"
Wyrzucenie opcji powyżej III roku
"Pracuje", "Nie pracuje" (najlepsze?)
Sampling opcji niepracującej

```{r}
model2<-randomForest::randomForest(Praca~.,data=df4)
print(model2)
table(df4$Praca)
```


###3 ROK RAZEM Z OPCJAMI WYZSZYMI###

```{r}
df5<-df3
Wekt<-c('III rok','IV rok', 'V rok', 'Później')
df5[,25]<-gsub(paste(Wekt, collapse = '|'), 'III rok i później', df5[,25])
df5[,25]<-parse_factor(df5[,25],levels=unique(sort(df5[,25])))
table(df5$Praca)
```

```{r}
model3<-randomForest::randomForest(Praca~.,data=df5)
print(model3)
```

Cóż, wyszło jeszcze gorzej.

###OPCJA ZEROJEDYNKOWA###

```{r}
#można to zrobić zgrabniej, ale na tym etapie chcę przede wszystkim sprawdzić, czy przyniesie to znaczącą poprawę
df6<-df3
Wekt<-c('Przed początkiem studiów','I rok','II rok','III rok','IV rok', 'V rok', 'Później')
df6[,25]<-gsub(paste(Wekt, collapse = '|'), 'Pracuję', df6[,25])
df6[,25]<-parse_factor(df6[,25],levels=unique(sort(df6[,25])))
levels(df6$Praca)
table(df6$Praca)
```

```{r}
set.seed(42)
model4<-randomForest(Praca~.,data=df6,ntrees=500,mtry=6,importance=TRUE,sampsize=c(155,155))
print(model4)
importance(model4,class=TRUE)
varImpPlot(model4)
str(model4)
```

W końcu wygląda to... no, może nie lepiej, ale ludzko. Wciąż jest bardzo duży błąd w opcji pracującej, ale klasyfikator zaczął chociaż myśleć, a nie automatycznie wybierać bezrobotnych.

```{r}
help(randomForest)
help(importance)
```

Atm to najlepsze, choć wciąż nie dobre. Gorzej radzi sobie z niepracującymi, za to nieco lepiej z pracującymi.

###WYRZUCENIE NIEZDECYDOWANYCH###

```{r}
df0<-data[,-18]
df0<-df0[,-1]
```

```{r}
colnames(df0)[1:32]<-c('Kobieta','Wiek','Wojewodztwo_pochodzenia', 'Wielkosc_miasta', 'Miasto', 'Wiecej_kierunkow', 'Rok','Prywatna','Zaocznie', 'Typ','Dziedzina','Kola','Organizacje','Samorzad','Srednia','Stypendium','Wiodace','Zapychacze','Zapychacze_dobor','Jezyk','Organizacja_uczelni','Plany','Trudnosc','Przydatnosc','Ogolna_ocena','Praca','Feedback','Akademik','Dom_mieszkanie_rodzinne','Wynajete_mieszkanie','Wynajety_pokoj','Inne')
df0<-df0%>%
  mutate(Dyscyplina = ifelse(Dziedzina %in% c('Biologia','Chemia', 'Geografia'),'Nauki przyrodnicze',ifelse(Dziedzina %in% c('Psychologia','Socjologia','Zarządzanie','Nauki o bezpieczeństwie','Pedagogika','Ekonomia/finanse','Ekonometria','Prawo/administracja','Dziennikarstwo/komunikacja społeczna'),'Nauki spoleczne',ifelse(Dziedzina %in% c('Inżynieria biomedyczna','Inżynieria chemiczna','Inżynieria materiałowa','Inżynieria mechaniczna','Inżynieria środowiska/energetyka/górnictwo','Inżynieria lądowa/budownictwo/transport',"Architektura","Automatyka/elektrotechnika"),'Nauki inzynieryjno-techniczne',ifelse(Dziedzina %in% c('Historia','Kulturoznawstwo/religioznawstwo',"Filologia"),'Nauki humanistyczne',ifelse(Dziedzina %in% c('Medycyna','Farmacja'),'Nauki o zdrowiu',ifelse(Dziedzina %in% c('Fizyka/astronomia','Informatyka/telekomunikacja',"Matematyka"),'Nauki scisle',ifelse(Dziedzina %in% c("Technologia żywności","Weterynaria/zootechnika" ),'Nauki rolnicze',levels(df$Dziedzina)[Dziedzina]))))))))
df0[,33]<-parse_factor(df0[,33],levels=unique(sort(df0[,33])))
df0<-df0[,-11]
Wekt<-c('Gdańsk','Gdynia','Sopot')
df0[,5]<-gsub(paste(Wekt, collapse = '|'), 'Trójmiasto', df0[,5])
Wekt<-c('Katowice','Bytom','Gliwice','Sosnowiec','Zabrze')
df0[,5]<-gsub(paste(Wekt, collapse = '|'), 'Śląsk', df0[,5])
df0[,5]<-parse_factor(df0[,5],levels=unique(sort(df0[,5])))
Wekt<-c('Przed początkiem studiów','I rok','II rok','III rok','IV rok', 'V rok', 'Później')
df0[,25]<-gsub(paste(Wekt, collapse = '|'), 'Pracuję', df0[,25])
df0[,25]<-parse_factor(df0[,25],levels=unique(sort(df0[,25])))
levels(df0$Praca)
table(df0$Praca)
```

```{r}
df0[!(is.na(df0[,26])),25:26] #analiza feedbacku - respondenci zgłaszający problemy z zaznaczeniem odpowiadających ich sytuacji opcji zostaną usunięci z danych
df01<-df0[-c(60, 103, 240, 244, 258,276, 321,345,347,348,366,87, 264),-26]

```


```{r}
table(df01$Praca)
model5<-randomForest(Praca~.,data=df01,ntree=1000,mtry=6,importance=TRUE,sampsize=c(150,150))
print(model5)
importance(model5,class=TRUE)
varImpPlot(model5)
#str(model5)

```

Z 13 usuniętych przypadków, 8 było błędni klasyfikowanych - 5 "pracujących" było uznawanych za bezrobotnych, 3 bezrobotnych - za pracujących. Przyniosło to delikatną poprawę.



